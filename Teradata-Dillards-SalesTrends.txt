# Query examples using the Dillard's transaction database provided by
# the University of Arkansas.

# Objective: Identify trends in sales volume based on time and location factors.

# Setting a default database...
DATABASE ua_dillards;

# First: Scanning for time gaps in database: How many distinct dates are there 
# in the transaction table for each month/year combination?...
SELECT EXTRACT(MONTH from saledate) AS sMonth, EXTRACT(YEAR from saledate) AS sYear, COUNT(DISTINCT saledate) AS DaysReported
FROM trnsact
GROUP BY sMonth, sYear
ORDER BY sYear, sMonth;

# 2004 has one missing day for November, December. 2005 has one missing day for March and only 27 days for August.
# These seem like holiday closings and perhaps August 2005 wasn't reported at full completion?
# The analysis will omit Aug 2005: SALEDATE < '2005-08-01'

#8 - 2004: 31
#9 - 2004: 30
#10 - 2004: 31
#11 - 2004: 29
#12 - 2004: 30
#1 - 2005: 31
#2 - 2005: 28
#3 - 2005: 30
#4 - 2005: 30
#5 - 2005: 31
#6 - 2005: 30
#7 - 2005: 31
#8 - 2005: 27

# What about at the store level? Anticipating patchy data due to reporting issues, store closings...
# Yes, there's variation. There are 12 cases of a store reporting less than 20 days in a month (incl. 5 reporting just 1 day).
# It may make sense to filter for stores HAVING >= 20 reporting days in a month or a similar criteria.
SELECT TOP 40 store, EXTRACT(MONTH from saledate) AS sMonth, 
	EXTRACT(YEAR from saledate) AS sYear, COUNT(DISTINCT saledate) AS DaysReported
FROM trnsact
GROUP BY store, sMonth, sYear
ORDER BY DaysReported ASC;

# Note: About 20% of stores have some missing data. We'll look “average daily revenue” to
# accomodate this. 

# Calculating average daily revenue for each store/month/year combination in the database with data 
# limited to stores reporting 20+ days for the month:
SELECT TOP 50 Days.store, Days.sMonth, Days.sYear, SUM(Days.SalesRevenue) AS tSalesRevenue,
	SUM(Days.DaysReported) AS DaysReported, SUM(Days.SalesRevenue)/SUM(Days.DaysReported) AS AvgDailyRevenue
FROM (
	SELECT store, EXTRACT(MONTH from saledate) AS sMonth, EXTRACT(YEAR from saledate) AS sYear, 
	COUNT(DISTINCT saledate) AS DaysReported, SUM(sprice) AS SalesRevenue
	FROM trnsact
	WHERE saledate < '2005-08-01' AND stype = 'P'
	GROUP BY store, sMonth, sYear
	HAVING DaysReported >= 20
	) AS Days 
GROUP BY Days.store, Days.sMonth, Days.sYear
ORDER BY AvgDailyRevenue DESC;

# Note: You can make a single label to describe the year and month information of a year/month/store 
# combination by writing: EXTRACT(YEAR from saledate)||EXTRACT(MONTH from saledate)
# For tips on string data syntax in Teradata, see:
# http://blog.extrobe.co.uk/blog/2015/02/13/concatenating-strings-in-teradata-and-what-to-watch-out-for-with-fixed-length-fields/

# Taking a look at the population statistics of store locations as they relate to sales performance...

# Defining tiers to evaluate the relationship with high school graduation rates in a store's MSA...
# Only 1 store lacks data on graduation rate, most store MSAs are 'High':
SELECT COUNT(DISTINCT store), CASE
	WHEN msa_high > 70 THEN 'High'
	WHEN msa_high < 70 AND msa_high >= 60 THEN 'Medium'
	WHEN msa_high < 60 THEN 'Low'
	END AS HighSchool
FROM store_msa
GROUP BY HighSchool;

# Looking at average daily revenue by HighSchool store categories...
# The 'medium' and 'low' MSA stores had higher average daily revenue but there were few such stores:
SELECT CASE
	WHEN msa_high > 70 THEN 'High'
	WHEN msa_high < 70 AND msa_high >= 60 THEN 'Medium'
	WHEN msa_high < 60 THEN 'Low'
	END AS HighSchool,
	SUM(Days.SalesRevenue) AS tSalesRevenue, SUM(Days.DaysReported) AS DaysReported, 
	SUM(Days.SalesRevenue)/SUM(Days.DaysReported) AS AvgDailyRevenue
FROM (
	SELECT store, EXTRACT(MONTH from saledate) AS sMonth, EXTRACT(YEAR from saledate) AS sYear, 
	COUNT(DISTINCT saledate) AS DaysReported, SUM(sprice) AS SalesRevenue
	FROM trnsact
	WHERE saledate < '2005-08-01' AND stype = 'P'
	GROUP BY store, sMonth, sYear
	HAVING DaysReported >= 20
	) AS Days 
	LEFT JOIN store_msa msa ON msa.store = Days.store
GROUP BY HighSchool;

# Income: Looking at stores in highest and lowest median MSA income for average daily revenue... 

# Note: we're looking to include something similar to a Top N component, but ORDER BY is not
# permitted in sub-queries. One way to accomplish is with a derived table using TOP,
# i.e.
# SELECT DISTINCT top3.sku, top3.city, top3.state
# FROM (SELECT TOP 3 t.sku, s.city, s.state
	# FROM trnsact t JOIN strinfo s
	# ON t.store = s.store
	# ORDER BY t.sprice DESC) top3
	
# Another option is to join on max/min values as below since these particular stores
# at max/min MSA income met the reporting criteria for the query.

# Highest/lowest median MSA income stores...
# These were in Spanish Fort, AL (highest income) and McAllen, TX (lowest income).
# As with the education query, the result is a bit surprising, with much higher
# average daily revenue in the lower income MSA:
SELECT Days.store, msa.city, msa.state, msa.msa_income,
	SUM(Days.SalesRevenue) AS tSalesRevenue, 
	SUM(Days.DaysReported) AS DaysReported, 
	SUM(Days.SalesRevenue)/SUM(Days.DaysReported) AS AvgDailyRevenue
FROM (
	SELECT store, EXTRACT(MONTH from saledate) AS sMonth, EXTRACT(YEAR from saledate) AS sYear, 
	COUNT(DISTINCT saledate) AS DaysReported, SUM(sprice) AS SalesRevenue
	FROM trnsact
	WHERE saledate < '2005-08-01' AND stype = 'P'
	GROUP BY store, sMonth, sYear
	HAVING DaysReported >= 20
	) AS Days
	LEFT JOIN store_msa msa ON msa.store = Days.store
	RIGHT JOIN (
		SELECT MAX(msa_income) as Imax, MIN(msa_income) as Imin
        FROM store_msa
	) msaMaxMin ON (msa.msa_income = msaMaxMin.Imax OR msa.msa_income = msaMaxMin.Imin)
GROUP BY Days.store, msa.city, msa.state, msa.msa_income;

# Examining variations in prices paid for a given item SKU...

# Identifying the SKU with greatest total sales the summer months (June, July, Aug)...
# Note: Teradata does not allow for IF statements - use CASE WHEN instead.
# The top SKU was #4108011, a Clinique product:
SELECT TOP 5 t.sku, d.dept, ski.style, ski.brand, ski.color, SUM(t.sprice) AS SalesRevenue, 
	CASE WHEN EXTRACT(MONTH from t.saledate) IN (6,7, 8) 
	THEN 'summer' 
	END AS SummerFlag
FROM trnsact t LEFT JOIN skuinfo ski ON t.sku = ski.sku LEFT JOIN deptinfo d ON ski.dept = d.dept
WHERE SummerFlag = 'summer' AND SALEDATE < '2005-08-01' AND STYPE = 'P'
GROUP BY t.sku, d.dept, ski.style, ski.brand, ski.color, SummerFlag
ORDER BY SalesRevenue DESC;

# Identifying the brand of the sku with the greatest standard deviation in sprice.
# Note: Including only SKUs that have over 100 associated transactions.
# The most volatile brand for prices appears to be 'Polo Fas':
SELECT TOP 5 s.sku, s.brand, COUNT(t.sku) AS transactions, AVG(t.sprice) AS avgPrice, STDDEV_SAMP(t.sprice) AS sdPrice
FROM skuinfo s, trnsact t
WHERE s.sku = t.sku AND t.saledate < '2005-08-01' AND t.stype = 'P'
GROUP BY s.sku, s.brand
HAVING transactions > 100
ORDER BY sdPrice DESC;




